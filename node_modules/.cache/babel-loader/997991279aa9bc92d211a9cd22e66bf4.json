{"ast":null,"code":"\"use strict\";\n\nvar _typeof = require(\"@babel/runtime-corejs3/helpers/typeof\");\n\nvar _WeakMap = require(\"@babel/runtime-corejs3/core-js-stable/weak-map\");\n\nvar _reduceInstanceProperty = require(\"@babel/runtime-corejs3/core-js-stable/instance/reduce\");\n\nvar _Object$keys2 = require(\"@babel/runtime-corejs3/core-js-stable/object/keys\");\n\nvar _Object$create = require(\"@babel/runtime-corejs3/core-js-stable/object/create\");\n\nvar _Symbol$replace = require(\"@babel/runtime-corejs3/core-js-stable/symbol/replace\");\n\nvar _sliceInstanceProperty = require(\"@babel/runtime-corejs3/core-js-stable/instance/slice\");\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs3/helpers/interopRequireDefault\");\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime-corejs3/regenerator\"));\n\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/inherits\"));\n\nvar _setPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/setPrototypeOf\"));\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/slicedToArray\"));\n\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/asyncToGenerator\"));\n\nvar _freeze = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/object/freeze\"));\n\nvar _map = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/map\"));\n\nvar _entries = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/object/entries\"));\n\nvar _forEach = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/for-each\"));\n\nvar _keys = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/object/keys\"));\n\nvar _isNan = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/number/is-nan\"));\n\nvar _stringify = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/json/stringify\"));\n\nvar _RESTController = _interopRequireDefault(require(\"./RESTController\"));\n\nfunction _wrapRegExp() {\n  _wrapRegExp = function _wrapRegExp(re, groups) {\n    return new BabelRegExp(re, void 0, groups);\n  };\n\n  var _super = RegExp.prototype,\n      _groups = new _WeakMap();\n\n  function BabelRegExp(re, flags, groups) {\n    var _this = new RegExp(re, flags);\n\n    return _groups.set(_this, groups || _groups.get(re)), (0, _setPrototypeOf2.default)(_this, BabelRegExp.prototype);\n  }\n\n  function buildGroups(result, re) {\n    var _context10;\n\n    var g = _groups.get(re);\n\n    return _reduceInstanceProperty(_context10 = _Object$keys2(g)).call(_context10, function (groups, name) {\n      return groups[name] = result[g[name]], groups;\n    }, _Object$create(null));\n  }\n\n  return (0, _inherits2.default)(BabelRegExp, RegExp), BabelRegExp.prototype.exec = function (str) {\n    var result = _super.exec.call(this, str);\n\n    return result && (result.groups = buildGroups(result, this)), result;\n  }, BabelRegExp.prototype[_Symbol$replace] = function (str, substitution) {\n    if (\"string\" == typeof substitution) {\n      var groups = _groups.get(this);\n\n      return _super[_Symbol$replace].call(this, str, substitution.replace(/\\$<([^>]+)>/g, function (_, name) {\n        return \"$\" + groups[name];\n      }));\n    }\n\n    if (\"function\" == typeof substitution) {\n      var _this = this;\n\n      return _super[_Symbol$replace].call(this, str, function () {\n        var args = arguments;\n        return \"object\" != _typeof(args[args.length - 1]) && (args = _sliceInstanceProperty([]).call(args)).push(buildGroups(args, _this)), substitution.apply(this, args);\n      });\n    }\n\n    return _super[_Symbol$replace].call(this, str, substitution);\n  }, _wrapRegExp.apply(this, arguments);\n}\n\nvar DEEP_INDEX_API_HOST = 'deep-index.moralis.io';\nvar DEEP_INDEX_SWAGGER_PATH = '/api-docs/v2/swagger.json';\nvar TrackingEventName = (0, _freeze.default)({\n  START_FUNCTION: 'Moralis SDK start'\n});\n\nvar fetchSwaggerJson = /*#__PURE__*/function () {\n  var _ref = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee() {\n    var _yield$RESTController, response;\n\n    return _regenerator.default.wrap(function (_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return _RESTController.default.ajax('GET', \"https://\".concat(DEEP_INDEX_API_HOST).concat(DEEP_INDEX_SWAGGER_PATH));\n\n          case 2:\n            _yield$RESTController = _context.sent;\n            response = _yield$RESTController.response;\n            return _context.abrupt(\"return\", response);\n\n          case 5:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function () {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nvar getPathByTag = function getPathByTag(swaggerJSON) {\n  var _context2;\n\n  var pathByTag = {};\n  var pathDetails = {};\n  (0, _map.default)(_context2 = (0, _entries.default)(swaggerJSON.paths)).call(_context2, function (_ref2) {\n    var _context3;\n\n    var _ref3 = (0, _slicedToArray2.default)(_ref2, 2),\n        pathName = _ref3[0],\n        requestData = _ref3[1];\n\n    return (0, _forEach.default)(_context3 = (0, _entries.default)(requestData)).call(_context3, function (_ref4) {\n      var _ref5 = (0, _slicedToArray2.default)(_ref4, 2),\n          method = _ref5[0],\n          data = _ref5[1];\n\n      var tags = data.tags;\n\n      if (tags.length > 0) {\n        if (!pathByTag[tags[0]]) {\n          pathByTag[tags[0]] = [];\n        }\n\n        pathByTag[tags[0]].push(data.operationId);\n        pathDetails[data.operationId] = {\n          method: method,\n          pathName: pathName,\n          data: data\n        };\n      }\n    });\n  });\n  return {\n    pathByTag: pathByTag,\n    pathDetails: pathDetails\n  };\n};\n\nvar fetchEndpoints = /*#__PURE__*/function () {\n  var _ref6 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2() {\n    var _context4;\n\n    var swaggerJSON, _yield$getPathByTag, pathDetails, data;\n\n    return _regenerator.default.wrap(function (_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            _context5.next = 2;\n            return fetchSwaggerJson();\n\n          case 2:\n            swaggerJSON = _context5.sent;\n            _context5.next = 5;\n            return getPathByTag(swaggerJSON);\n\n          case 5:\n            _yield$getPathByTag = _context5.sent;\n            pathDetails = _yield$getPathByTag.pathDetails;\n            data = [];\n            (0, _forEach.default)(_context4 = (0, _keys.default)(pathDetails)).call(_context4, function (x) {\n              var item = pathDetails[x];\n              var endpoint = {\n                method: item.method.toUpperCase(),\n                group: item.data.tags[0],\n                name: x,\n                url: item.pathName.split('{').join(':').split('}').join('')\n              };\n              data.push(endpoint);\n            });\n            return _context5.abrupt(\"return\", data);\n\n          case 10:\n          case \"end\":\n            return _context5.stop();\n        }\n      }\n    }, _callee2);\n  }));\n\n  return function () {\n    return _ref6.apply(this, arguments);\n  };\n}();\n/**\n * Compares if the semantic version of version1 is larger than version2\n */\n\n\nvar isSemanticVersionLarger = function isSemanticVersionLarger(version1, version2) {\n  var _context6, _context7;\n\n  var _version1$split = version1.split('-'),\n      _version1$split2 = (0, _slicedToArray2.default)(_version1$split, 2),\n      version1Main = _version1$split2[0],\n      version1Pre = _version1$split2[1];\n\n  var version1Arr = (0, _map.default)(_context6 = version1Main.split('.')).call(_context6, function (s) {\n    return Number(s);\n  });\n\n  var _version2$split = version2.split('-'),\n      _version2$split2 = (0, _slicedToArray2.default)(_version2$split, 2),\n      version2Main = _version2$split2[0],\n      version2Pre = _version2$split2[1];\n\n  var version2Arr = (0, _map.default)(_context7 = version2Main.split('.')).call(_context7, function (s) {\n    return Number(s);\n  });\n\n  for (var index = 0; index < 3; index++) {\n    var compare1 = version1Arr[index];\n    var compare2 = version2Arr[index];\n    if (compare1 > compare2) return true;\n    if (compare1 < compare2) return false;\n    if (!(0, _isNan.default)(compare1) && (0, _isNan.default)(compare2)) return true;\n    if ((0, _isNan.default)(compare1) && !(0, _isNan.default)(compare2)) return false;\n  } // Compare pre-releasees if main versions are the same\n\n\n  if (version1Pre && version2Pre) {\n    var _version1Pre$split$, _version2Pre$split$;\n\n    var version1PreNumber = (_version1Pre$split$ = version1Pre.split('.')[1]) !== null && _version1Pre$split$ !== void 0 ? _version1Pre$split$ : 0;\n    var version2PreNumber = (_version2Pre$split$ = version2Pre.split('.')[1]) !== null && _version2Pre$split$ !== void 0 ? _version2Pre$split$ : 0;\n    return version1PreNumber > version2PreNumber;\n  } // If version2 is a pre-release and version1 is not, then version 1 is newer\n\n\n  if (version2Pre) {\n    return true;\n  }\n\n  return false;\n};\n\nvar checkForSdkUpdates = /*#__PURE__*/function () {\n  var _ref7 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee3() {\n    var _yield$RESTController2, response, latestVersion, installedVersion;\n\n    return _regenerator.default.wrap(function (_context8) {\n      while (1) {\n        switch (_context8.prev = _context8.next) {\n          case 0:\n            _context8.prev = 0;\n            _context8.next = 3;\n            return _RESTController.default.ajax('GET', 'https://www.unpkg.com/moralis/package.json');\n\n          case 3:\n            _yield$RESTController2 = _context8.sent;\n            response = _yield$RESTController2.response;\n            latestVersion = response.version;\n            installedVersion = \"1.9.0\";\n            if (isSemanticVersionLarger(latestVersion, installedVersion)) // eslint-disable-next-line no-console\n              console.warn(\"Moralis: You are not using the latest version of the SDK. Please update it as soon as possible to enjoy the newest features. Most recent version: \".concat(latestVersion));\n            _context8.next = 12;\n            break;\n\n          case 10:\n            _context8.prev = 10;\n            _context8.t0 = _context8[\"catch\"](0);\n\n          case 12:\n          case \"end\":\n            return _context8.stop();\n        }\n      }\n    }, _callee3, null, [[0, 10]]);\n  }));\n\n  return function () {\n    return _ref7.apply(this, arguments);\n  };\n}();\n\nvar trackEvent = /*#__PURE__*/function () {\n  var _ref8 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee4(name, subdomain, options) {\n    var _yield$RESTController3, response;\n\n    return _regenerator.default.wrap(function (_context9) {\n      while (1) {\n        switch (_context9.prev = _context9.next) {\n          case 0:\n            _context9.prev = 0;\n            _context9.next = 3;\n            return _RESTController.default.ajax('POST', 'https://internal-api.moralis.io/api/functions/trackEvent', (0, _stringify.default)({\n              subdomain: subdomain,\n              event: name,\n              options: options\n            }), {\n              Accept: 'application/json',\n              'Content-Type': 'application/json'\n            });\n\n          case 3:\n            _yield$RESTController3 = _context9.sent;\n            response = _yield$RESTController3.response;\n            return _context9.abrupt(\"return\", response.result);\n\n          case 8:\n            _context9.prev = 8;\n            _context9.t0 = _context9[\"catch\"](0);\n\n          case 10:\n          case \"end\":\n            return _context9.stop();\n        }\n      }\n    }, _callee4, null, [[0, 8]]);\n  }));\n\n  return function () {\n    return _ref8.apply(this, arguments);\n  };\n}();\n/**\n * Regex to validate serverUrl, for example: https://xxxxxxxxxxxx.yyyyyyyyyy.zzzzzz:1234/server\n * It's very generous and doesn't assume the value of domain, subdomain and port, it only checks if we can extract\n * a subddomain\n */\n\n\nvar validServerUrlRegex = /*#__PURE__*/_wrapRegExp(/^https?:\\/\\/([0-9A-Z_a-z]+\\.[0-9A-Z_a-z]+\\.[0-9A-Z_a-z]+)(:[0-9]{4})?\\/server\\/?$/, {\n  subdomain: 1\n});\n\nvar validateServerUrl = function validateServerUrl(serverUrl) {\n  return validServerUrlRegex.test(serverUrl);\n};\n\nvar getSubdomain = function getSubdomain(serverUrl) {\n  var _match$groups$subdoma, _match$groups;\n\n  var isValidServerUrl = validateServerUrl(serverUrl);\n\n  if (!isValidServerUrl) {\n    return null;\n  }\n\n  var match = validServerUrlRegex.exec(serverUrl);\n  return (_match$groups$subdoma = match === null || match === void 0 ? void 0 : (_match$groups = match.groups) === null || _match$groups === void 0 ? void 0 : _match$groups.subdomain) !== null && _match$groups$subdoma !== void 0 ? _match$groups$subdoma : null;\n};\n\nmodule.exports = {\n  fetchSwaggerJson: fetchSwaggerJson,\n  getPathByTag: getPathByTag,\n  fetchEndpoints: fetchEndpoints,\n  checkForSdkUpdates: checkForSdkUpdates,\n  trackEvent: trackEvent,\n  TrackingEventName: TrackingEventName,\n  getSubdomain: getSubdomain\n};","map":null,"metadata":{},"sourceType":"script"}